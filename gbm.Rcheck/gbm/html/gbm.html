<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Generalized Boosted Regression Modeling</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for gbm {gbm}"><tr><td>gbm {gbm}</td><td align="right">R Documentation</td></tr></table>
<h2>Generalized Boosted Regression Modeling</h2>


<h3>Description</h3>

<p>
Fits generalized boosted regression models.
</p>


<h3>Usage</h3>

<pre>
gbm(formula = formula(data),
    distribution = "bernoulli",
    data = list(),
    weights,
    var.monotone = NULL,
    n.trees = 100,
    interaction.depth = 1,
    n.minobsinnode = 10,
    shrinkage = 0.001,
    bag.fraction = 0.5,
    train.fraction = 1.0,
    cv.folds=0,
    keep.data = TRUE,
    verbose = TRUE,
    class.stratify.cv)

gbm.fit(x,y,
        offset = NULL,
        misc = NULL,
        distribution = "bernoulli",
        w = NULL,
        var.monotone = NULL,
        n.trees = 100,
        interaction.depth = 1,
        n.minobsinnode = 10,
        shrinkage = 0.001,
        bag.fraction = 0.5,
        train.fraction = 1.0,
        keep.data = TRUE,
        verbose = TRUE,
        var.names = NULL,
        response.name = NULL)

gbm.more(object,
         n.new.trees = 100,
         data = NULL,
         weights = NULL,
         offset = NULL,
         verbose = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>formula</code></td>
<td>
a symbolic description of the model to be fit. The formula may 
include an offset term (e.g. y~offset(n)+x). If <code>keep.data=FALSE</code> in 
the initial call to <code>gbm</code> then it is the user's responsibility to 
resupply the offset to <code><a href="gbm.html">gbm.more</a></code>.</td></tr>
<tr valign="top"><td><code>distribution</code></td>
<td>
a character string specifying the name of the distribution 
to use or a list with a component <code>name</code> specifying the distribution 
and any additional parameters needed. If not specified, <code>gbm</code> will
try to guess: if the response has only 2 unique values, bernoulli is
assumed; otherwise, if the response is a factor, kclass is assumed; otherwise,
if the response has class "Surv", coxph is assumed; otherwise, bisquare
is assumed.
<br>
Currently available options are "gaussian" (squared error), "laplace"
(absolute loss), "bisquare" (bisquare loss), "tdist" (t-distribution loss),
"bernoulli" (logistic regression for 0-1 outcomes), 
"kclass" (classification when there are more than 2 classes),
"adaboost" (the AdaBoost exponential loss for 0-1 outcomes), "poisson" 
(count outcomes), "coxph" (right censored observations) or "quantile".
<br>
If quantile regression is specifie, <code>distribution</code> must a list of the form 
<code>list(name="quantile",alpha=0.25)</code> where <code>alpha</code> is the quantile 
to estimate. The current version's  quantile regression method does
not handle non-constant weights and will stop.
<br>
If "bisquare" is specified, the method defaults to being
85% efficient for normally distributed data, and this can be controlled
by setting distribution to be a list with 2 elements, the first of which
should be <code>name="bisquare"</code>, the second of which should be
<code>eff=c</code>, where
<code>c</code> is a value between 0.8 and 0.95 representing the method's
efficience when the data are normally distributed.
<br>
If "tdist" is specified,
the default
degrees of freedom is 4 and this can be controlled by specifying
<code>distribution=list( name="tdist", df=DF)</code> where <code>DF</code> is your chosen degrees of freedom.
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
an optional data frame containing the variables in the model. By
default the variables are taken from <code>environment(formula)</code>, typically 
the environment from which <code>gbm</code> is called. If <code>keep.data=TRUE</code> in 
the initial call to <code>gbm</code> then <code>gbm</code> stores a copy with the 
object. If <code>keep.data=FALSE</code> then subsequent calls to 
<code><a href="gbm.html">gbm.more</a></code> must resupply the same dataset. It becomes the user's 
responsibility to resupply the same data at this point.</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
an optional vector of weights to be used in the fitting process. 
Must be positive but do not need to be normalized. If <code>keep.data=FALSE</code> 
in the initial call to <code>gbm</code> then it is the user's responsibility to 
resupply the weights to <code><a href="gbm.html">gbm.more</a></code>.</td></tr>
<tr valign="top"><td><code>var.monotone</code></td>
<td>
an optional vector, the same length as the number of
predictors, indicating which variables have a monotone increasing (+1),
decreasing (-1), or arbitrary (0) relationship with the outcome.</td></tr>
<tr valign="top"><td><code>n.trees</code></td>
<td>
the total number of trees to fit. This is equivalent to the
number of iterations and the number of basis functions in the additive
expansion.</td></tr>
<tr valign="top"><td><code>cv.folds</code></td>
<td>
Number of cross-validation folds to perform. If <code>cv.folds</code>&gt;1 then
<code>gbm</code>, in addition to the usual fit, will perform a cross-validation, calculate
an estimate of generalization error returned in <code>cv.error</code>.</td></tr>
<tr valign="top"><td><code>interaction.depth</code></td>
<td>
The maximum depth of variable interactions. 1 implies
an additive model, 2 implies a model with up to 2-way interactions, etc.</td></tr>
<tr valign="top"><td><code>n.minobsinnode</code></td>
<td>
minimum number of observations in the trees terminal
nodes. Note that this is the actual number of observations not the total
weight.</td></tr>
<tr valign="top"><td><code>shrinkage</code></td>
<td>
a shrinkage parameter applied to each tree in the expansion.
Also known as the learning rate or step-size reduction.</td></tr>
<tr valign="top"><td><code>bag.fraction</code></td>
<td>
the fraction of the training set observations randomly
selected to propose the next tree in the expansion. This introduces randomnesses
into the model fit. If <code>bag.fraction</code>&lt;1 then running the same model twice
will result in similar but different fits. <code>gbm</code> uses the R random number
generator so <code>set.seed</code> can ensure that the model can be
reconstructed. Preferably, the user can save the returned
<code><a href="gbm.object.html">gbm.object</a></code> using <code><a href="../../base/html/save.html">save</a></code>.</td></tr>
<tr valign="top"><td><code>train.fraction</code></td>
<td>
The first <code>train.fraction * nrows(data)</code>
observations are used to fit the <code>gbm</code> and the remainder are used for
computing out-of-sample estimates of the loss function.</td></tr>
<tr valign="top"><td><code>keep.data</code></td>
<td>
a logical variable indicating whether to keep the data and
an index of the data stored with the object. Keeping the data and index makes
subsequent calls to <code><a href="gbm.html">gbm.more</a></code> faster at the cost of storing an
extra copy of the dataset.</td></tr>
<tr valign="top"><td><code>object</code></td>
<td>
a <code>gbm</code> object created from an initial call to
<code><a href="gbm.html">gbm</a></code>.</td></tr>
<tr valign="top"><td><code>n.new.trees</code></td>
<td>
the number of additional trees to add to <code>object</code>.</td></tr>
<tr valign="top"><td><code>verbose</code></td>
<td>
If TRUE, gbm will print out progress and performance indicators.
If this option is left unspecified for gbm.more then it uses <code>verbose</code> from
<code>object</code>.</td></tr>
<tr valign="top"><td><code>class.stratify.cv</code></td>
<td>
whether or not the cross-validation should be stratified by
class. Defaults to <code>TRUE</code> for <code>distribution="kclass"</code> and is only 
implementated for <code>kclass</code> and <code>bernoulli</code>. The purpose of stratifying
the cross-validation is to help avoiding situations in which training sets do
not contain all classes.</td></tr>
<tr valign="top"><td><code>x, y</code></td>
<td>
For <code>gbm.fit</code>: <code>x</code> is a data frame or data matrix containing the
predictor variables and <code>y</code> is the vector of outcomes. The number of rows
in <code>x</code> must be the same as the length of <code>y</code>.</td></tr>
<tr valign="top"><td><code>offset</code></td>
<td>
a vector of values for the offset</td></tr>
<tr valign="top"><td><code>misc</code></td>
<td>
For <code>gbm.fit</code>: <code>misc</code> is an R object that is simply passed on to
the gbm engine. It can be used for additional data for the specific distribution.
Currently it is only used for passing the censoring indicator for the Cox
proportional hazards model.</td></tr>
<tr valign="top"><td><code>w</code></td>
<td>
For <code>gbm.fit</code>: <code>w</code> is a vector of weights of the same
length as the <code>y</code>.</td></tr>
<tr valign="top"><td><code>var.names</code></td>
<td>
For <code>gbm.fit</code>: A vector of strings of length equal to the
number of columns of <code>x</code> containing the names of the predictor variables.</td></tr>
<tr valign="top"><td><code>response.name</code></td>
<td>
For <code>gbm.fit</code>: A character string label for the response
variable.</td></tr>
</table>

<h3>Details</h3>

<p>
See <code>vignette("gbm")</code> for technical details of the package. Also available 
at <a href="../doc/gbm.pdf">../doc/gbm.pdf</a> (if you are using HTML help).
</p>
<p>
This package implements the generalized boosted modeling framework.
Boosting is the process of iteratively adding basis functions in a greedy
fashion so that each additional basis function further reduces the selected
loss function. This implementation closely follows Friedman's Gradient
Boosting Machine (Friedman, 2001).
</p>
<p>
In addition to many of the features documented in the Gradient Boosting Machine,
<code>gbm</code> offers additional features including the out-of-bag estimator for
the optimal number of iterations, the ability to store and manipulate the
resulting <code>gbm</code> object, and a variety of other loss functions that had not
previously had associated boosting algorithms, including the Cox partial
likelihood for censored data, the poisson likelihood for count outcomes, and a
gradient boosting implementation to minimize the AdaBoost exponential loss
function.
</p>
<p>
<code>gbm.fit</code> provides the link between R and the C++ gbm engine. <code>gbm</code>
is a front-end to <code>gbm.fit</code> that uses the familiar R modeling formulas.
However, <code><a href="../../stats/html/model.frame.html">model.frame</a></code> is very slow if there are many
predictor variables. For power-users with many variables use <code>gbm.fit</code>.
For general practice <code>gbm</code> is preferable.
</p>


<h3>Value</h3>

<p>
<code>gbm</code>, <code>gbm.fit</code>, and <code>gbm.more</code> return a
<code><a href="gbm.object.html">gbm.object</a></code>.</p>

<h3>Author(s)</h3>

<p>
Greg Ridgeway <a href="mailto:gregr@rand.org">gregr@rand.org</a>
</p>
<p>
Quantile regression code developed by Brian Kriegler <a href="mailto:bk@stat.ucla.edu">bk@stat.ucla.edu</a>
</p>


<h3>References</h3>

<p>
Y. Freund and R.E. Schapire (1997) &ldquo;A decision-theoretic generalization of
on-line learning and an application to boosting,&rdquo; <EM>Journal of Computer and
System Sciences,</EM> 55(1):119-139.
</p>
<p>
G. Ridgeway (1999). &ldquo;The state of boosting,&rdquo; <EM>Computing Science and
Statistics</EM> 31:172-181.
</p>
<p>
J.H. Friedman, T. Hastie, R. Tibshirani (2000). &ldquo;Additive Logistic Regression:
a Statistical View of Boosting,&rdquo; <EM>Annals of Statistics</EM> 28(2):337-374.
</p>
<p>
J.H. Friedman (2001). &ldquo;Greedy Function Approximation: A Gradient Boosting
Machine,&rdquo; <EM>Annals of Statistics</EM> 29(5):1189-1232.
</p>
<p>
J.H. Friedman (2002). &ldquo;Stochastic Gradient Boosting,&rdquo; <EM>Computational Statistics
and Data Analysis</EM> 38(4):367-378.
</p>
<p>
B. Kriegler (2007). <EM>Cost-Sensitive Stochastic Gradient Boosting Within a 
Quantitative Regression Framework</EM>. PhD dissertation, UCLA Statistics. 
<a href="http://theses.stat.ucla.edu/57/KrieglerDissertation.pdf">http://theses.stat.ucla.edu/57/KrieglerDissertation.pdf</a>
</p>
<p>
<a href="http://www.i-pensieri.com/gregr/gbm.shtml">http://www.i-pensieri.com/gregr/gbm.shtml</a>
</p>
<p>
<a href="http://www-stat.stanford.edu/~jhf/R-MART.html">http://www-stat.stanford.edu/~jhf/R-MART.html</a>
</p>


<h3>See Also</h3>

<p>
<code><a href="gbm.object.html">gbm.object</a></code>,
<code><a href="gbm.perf.html">gbm.perf</a></code>,
<code><a href="plot.gbm.html">plot.gbm</a></code>,
<code><a href="predict.gbm.html">predict.gbm</a></code>,
<code><a href="summary.gbm.html">summary.gbm</a></code>,
<code><a href="pretty.gbm.tree.html">pretty.gbm.tree</a></code>.
</p>


<h3>Examples</h3>

<pre>
# A least squares regression example
# create some data

N &lt;- 1000
X1 &lt;- runif(N)
X2 &lt;- 2*runif(N)
X3 &lt;- ordered(sample(letters[1:4],N,replace=TRUE),levels=letters[4:1])
X4 &lt;- factor(sample(letters[1:6],N,replace=TRUE))
X5 &lt;- factor(sample(letters[1:3],N,replace=TRUE))
X6 &lt;- 3*runif(N)
mu &lt;- c(-1,0,1,2)[as.numeric(X3)]

SNR &lt;- 10 # signal-to-noise ratio
Y &lt;- X1**1.5 + 2 * (X2**.5) + mu
sigma &lt;- sqrt(var(Y)/SNR)
Y &lt;- Y + rnorm(N,0,sigma)

# introduce some missing values
X1[sample(1:N,size=500)] &lt;- NA
X4[sample(1:N,size=300)] &lt;- NA

data &lt;- data.frame(Y=Y,X1=X1,X2=X2,X3=X3,X4=X4,X5=X5,X6=X6)

# fit initial model
gbm1 &lt;- gbm(Y~X1+X2+X3+X4+X5+X6,         # formula
    data=data,                   # dataset
    var.monotone=c(0,0,0,0,0,0), # -1: monotone decrease,
                                 # +1: monotone increase,
                                 #  0: no monotone restrictions
    distribution="gaussian",     # bernoulli, adaboost, gaussian,
                                 # poisson, coxph, and quantile available
    n.trees=3000,                # number of trees
    shrinkage=0.005,             # shrinkage or learning rate,
                                 # 0.001 to 0.1 usually work
    interaction.depth=3,         # 1: additive model, 2: two-way interactions, etc.
    bag.fraction = 0.5,          # subsampling fraction, 0.5 is probably best
    train.fraction = 0.5,        # fraction of data for training,
                                 # first train.fraction*N used for training
    n.minobsinnode = 10,         # minimum total weight needed in each node
    cv.folds = 5,                # do 5-fold cross-validation
    keep.data=TRUE,              # keep a copy of the dataset with the object
    verbose=TRUE)                # print out progress

# check performance using an out-of-bag estimator
# OOB underestimates the optimal number of iterations
best.iter &lt;- gbm.perf(gbm1,method="OOB")
print(best.iter)

# check performance using a 50% heldout test set
best.iter &lt;- gbm.perf(gbm1,method="test")
print(best.iter)

# check performance using 5-fold cross-validation
best.iter &lt;- gbm.perf(gbm1,method="cv")
print(best.iter)

# plot the performance
# plot variable influence
summary(gbm1,n.trees=1)         # based on the first tree
summary(gbm1,n.trees=best.iter) # based on the estimated best number of trees

# compactly print the first and last trees for curiosity
print(pretty.gbm.tree(gbm1,1))
print(pretty.gbm.tree(gbm1,gbm1$n.trees))

# make some new data
N &lt;- 1000
X1 &lt;- runif(N)
X2 &lt;- 2*runif(N)
X3 &lt;- ordered(sample(letters[1:4],N,replace=TRUE))
X4 &lt;- factor(sample(letters[1:6],N,replace=TRUE))
X5 &lt;- factor(sample(letters[1:3],N,replace=TRUE))
X6 &lt;- 3*runif(N)
mu &lt;- c(-1,0,1,2)[as.numeric(X3)]

Y &lt;- X1**1.5 + 2 * (X2**.5) + mu + rnorm(N,0,sigma)

data2 &lt;- data.frame(Y=Y,X1=X1,X2=X2,X3=X3,X4=X4,X5=X5,X6=X6)

# predict on the new data using "best" number of trees
# f.predict generally will be on the canonical scale (logit,log,etc.)
f.predict &lt;- predict.gbm(gbm1,data2,best.iter)

# least squares error
print(sum((data2$Y-f.predict)^2))

# create marginal plots
# plot variable X1,X2,X3 after "best" iterations
par(mfrow=c(1,3))
plot.gbm(gbm1,1,best.iter)
plot.gbm(gbm1,2,best.iter)
plot.gbm(gbm1,3,best.iter)
par(mfrow=c(1,1))
# contour plot of variables 1 and 2 after "best" iterations
plot.gbm(gbm1,1:2,best.iter)
# lattice plot of variables 2 and 3
plot.gbm(gbm1,2:3,best.iter)
# lattice plot of variables 3 and 4
plot.gbm(gbm1,3:4,best.iter)

# 3-way plots
plot.gbm(gbm1,c(1,2,6),best.iter,cont=20)
plot.gbm(gbm1,1:3,best.iter)
plot.gbm(gbm1,2:4,best.iter)
plot.gbm(gbm1,3:5,best.iter)

# do another 100 iterations
gbm2 &lt;- gbm.more(gbm1,100,
                 verbose=FALSE) # stop printing detailed progress
</pre>



<hr><div align="center">[Package <em>gbm</em> version 1.7-1 <a href="00Index.html">Index]</a></div>

</body></html>
